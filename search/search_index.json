{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"C++ testing made simple","text":"A simple testNested test suitesExceptionsAsserting collectionsParametrized tests <pre><code>#include &lt;cest&gt;\n\ndescribe(\"A mars rover\", []() {\n  it(\"can go forward\", []() {\n    MarsRover rover(0,0);\n\n    rover.move(Direction::Forward);\n\n    expect(rover.position.x).toBe(1);\n  });\n});\n</code></pre> <pre><code>#include &lt;cest&gt;\n\ndescribe(\"DatabaseConnector\", []() {\n  describe(\"connect()\", []() {\n    it(\"succeeds at connecting to host\", []() {\n      auto result = DatabaseConnector().connect();\n      expect(result).toEqual(Result::SUCCESS);\n    });\n  });\n\n  describe(\"disconnect()\", []() {\n    it(\"fails to disconnect if not connected\", []() {\n      auto result = DatabaseConnector().disconnect();\n      expect(result).toEqual(Result::FAILURE);\n    });\n  });\n});\n</code></pre> <pre><code>#include &lt;cest&gt;\n\ndescribe(\"Discount vouchers\", []() {\n  it(\"can only have positive discount\", []() {\n    assertRaises&lt;InvalidDiscountException&gt;() {\n      DiscountVoucher voucher(-30);\n    }\n  });\n});\n</code></pre> <pre><code>#include &lt;cest&gt;\n\ndescribe(\"Message queue\", []() {\n  it(\"can contain multiple messages\", []() {\n    std::vector&lt;string&gt; pendingData { \"&lt;header&gt;\", \"20 apples\" };\n\n    expect(pendingData).toHaveLength(2);\n    expect(pendingData).toContain(\"&lt;header&gt;);\n    expect(pendingData[1]).toMatch(Regex(\".*\\\\d+ apples\"));\n  });\n});\n</code></pre> <pre><code>#include &lt;cest&gt;\n\ndescribe(\"Hardware Version register\", []() {\n  it(\"is mirrored in two addresses in the memory map\", []() {\n    withParameter&lt;uint32_t *&gt;().\n      withValue(0x00A1000F).\n      withValue(0xFFA1000F).\n      thenDo([](uint32_t *address) {\n        uint32_t version = *address;\n        expect(version).toBe(123);\n      });\n  });\n});\n</code></pre> <ul> <li> <p> Get Started</p> <p>Check out the quick start guide and start building your first test in a minute!</p> <p> Quick start</p> </li> <li> <p> API Reference</p> <p>Find all the nitty gritty details of Cest and make the most out of your tests.</p> <p> API Reference</p> </li> </ul>"},{"location":"#main-features","title":"Main features","text":""},{"location":"#single-header","title":"Single Header","text":"<p>All features are included in a single C++ header, making it easy to integrate into any project's existing pipeline. Just include <code>cest</code> in each test file to compile a self-contained and runnable test</p>"},{"location":"#powerful-test-runner","title":"Powerful Test Runner","text":"<p>Avoid rolling your own code to manage test suites, and run all Cest tests with its built-in Runner. Filter tests by name or only run failed tests.</p>"},{"location":"#bdd-inspired-api","title":"BDD inspired API","text":"<p>Write tests in a familiar BDD style, using <code>it</code>, <code>describe</code>, and <code>expect</code> \u2014 no complex C++ knowledge required.</p>"},{"location":"#feature-rich-from-the-get-go","title":"Feature rich from the get-go","text":"<p>Includes exception handling assertions, parametrized tests, pointer assertions, integration with STL collections, and more. Want more? Planned features include parametric tests, extended collection support, async execution support, and more</p>"},{"location":"#create-expressive-tests-for-your-c-code","title":"Create expressive tests for your C code","text":"<p>Are you creating a C application or library? Use Cest Framework to add expressivity and semantics to your C codebase, by using all the features provided by C++ in your tests.</p> <p></p>"},{"location":"#contribute-to-cest-framework","title":"Contribute to Cest Framework","text":"<p>Do you like Cest Framework? Are you planning on using it on your C or C++ projects? If you enjoy it, it would be great to have your Star in the GitHub repository!</p> <p>Are you missing any feature? Open an issue and let's start the conversation to get it implemented.</p> <p>Do you want to contribute? Check the contribution guide in the GitHub repository README file, and start improving Cest.</p> <p>These are the current contributors of Cest. Click on their avatars to visit their GitHub profiles:</p> <p> </p>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#test-definition","title":"Test definition","text":""},{"location":"reference/#building-blocks","title":"Building blocks","text":"<p>Test suites are defined by a top-level <code>describe</code> block. Each <code>describe</code> block takes one lambda function as the main test body, and can have many <code>it</code> blocks. All the <code>it</code> blocks will be executed when running the test.</p> <p>Each <code>describe</code> block may have multiple nested <code>describe</code> blocks. All <code>describe</code> blocks will be executed in outside-inside order, starting from the top-level describe block.</p> <p>For example, with the following set of <code>describe</code> and <code>it</code> blocks:</p> <p>Nested test suites</p> <pre><code>describe(\"Socket\", []() {\n  describe(\"send()\", []() {\n    it(\"sends data\", []() {});\n  });\n\n  describe(\"recv()\", []() {\n    it(\"receives data\", []() {});\n  });\n\n  it(\"does nothing\", []() {});\n});\n</code></pre> <p>The statements in the top-level <code>describe</code> block will be executed first (the <code>does nothing</code> test case), and then the <code>send()</code> and <code>recv()</code> describe blocks will be executed consecutively.</p> <p>Warning</p> <p>Due to the way <code>describe</code> blocks are arranged in compilation-time, Cest does not support having multiple top-level <code>describe</code> blocks in a single test file.</p> <p>Test case execution can be controlled using the <code>xit</code> and <code>fit</code> keywords:</p> <ul> <li><code>xit</code> will skip the test.</li> <li><code>fit</code> will execute only that specific test.</li> </ul> <p>This can be useful if you want to avoid running a test that is not yet ready, or you want to focus in fixing a single test.</p> <p>Basic test definition</p> <pre><code>describe(\"each test suite\", []() {\n  it(\"may contain\", []() {});\n\n  it(\"multiple test cases\", []() {});\n\n  fit(\"only this test will run\", []() {});\n\n  xit(\"this test will be skipped\", []() {});\n});\n</code></pre>"},{"location":"reference/#pre-conditions-and-post-conditions","title":"Pre-conditions and post-conditions","text":"<p>Execution of test cases and suites can be wrapped to control setup and teardown using the <code>beforeEach</code>, <code>afterEach</code>, <code>beforeAll</code> and <code>afterAll</code> keywords. Order of execution of the setup and teardown keywords is <code>beforeAll</code> \u2192 <code>beforeEach</code> \u2192 test case \u2192 <code>afterEach</code> \u2192 <code>afterAll</code>.</p> <p>Warning</p> <p>Even though having multiple pre-condition or post-condition keywords in a single test suite will compile, the actual functions that will be used by Cest is not guaranteed in that case. To avoid problems, each test suite must contain only one of each.</p> <p>Using setup and teardown keywords is the best way to gracefully control post and pre-conditions in your test suites and cases.</p> <p>Wrapping each test case</p> <pre><code>int *data = nullptr;\n\ndescribe(\"Behavior of pre and post conditions\", [&amp;]() { // (1)\n  beforeEach([&amp;]() { // (1)\n    data = new int;\n    *data = 0;\n  });\n\n  afterEach([&amp;]() { // (1)\n    delete data;\n  });\n\n  it(\"has no memory leaks\", [&amp;]() { // (1)\n    expect(*data).toEqual(0);\n  });\n});\n</code></pre> <ol> <li>Note how the lambda expression is defined with reference capture scope (<code>&amp;</code>), as the test is accesing the <code>data</code> variable which is defined at the top level.</li> </ol> <p>Wrapping each test suite</p> <pre><code>DatabaseConnection connection;\n\ndescribe(\"Behavior of pre and post conditions\", [&amp;]() { // (1)\n  beforeAll([&amp;]() { // (1)\n    connection.connectTo(\"localhost\");\n  });\n\n  afterAll([&amp;]() { // (1)\n    connection.close();\n  });\n\n  it(\"can perform queries\", [&amp;]() { // (1)\n    expect(connection.getById(\"\")).toBeNull();\n  });\n});\n</code></pre> <ol> <li>Note how the lambda expression is defined with reference capture scope (<code>&amp;</code>), as the test is accesing the <code>data</code> variable which is defined at the top level.</li> </ol>"},{"location":"reference/#assertions","title":"Assertions","text":"<p>Cest uses matchers to assert values in tests. Assertion keywords are generated through templates, ranging from common assertions to specialization to specific types (like strings, lists, etc...).</p> <p>An assertion failing to validate its value will stop the test, showing the error through the output. Remaining tests will continue to run.</p> <p>The basic form of any assertion is:</p> <pre><code>expect&lt;T&gt;(value).[assertion](...);\n</code></pre> <p>Where assertion can be comparing it to another value, validating its NULL, validating its empty... For example:</p> <pre><code>expect(\"hello\").toEqual(\"bye\"); // This will fail, as hello does not match bye\nexpect(0x00000000).toBeNull(); // This will pass, as NULL equals zero\n</code></pre> <p>Warning</p> <p>Since assertions are generated through templates, asserted type <code>T</code> must implement specific operators to match them to the target value. Basic (built-in) types implement them, but if using custom types (like classes or structures), the operators will have to be manually overloaded.</p> <p>To assert negated values, you can use the <code>Not</code> operator. For example:</p> <pre><code>expect(\"hello\").Not-&gt;toEqual(\"bye\");\nexpect(123).Not-&gt;toBe(321);\n</code></pre>"},{"location":"reference/#generic-types","title":"Generic types","text":"<p>These assertions apply to a <code>value</code> of any type <code>T</code>, including the ones Cest has a specialization for (see next sections).</p> Method Description Equivalient operator <code>toBe&lt;T&gt;(T expected)</code> Passes if <code>value</code> matches <code>expected</code>, evaluated through expression <code>(value == expected)</code> <code>operator==</code> <code>toEqual&lt;T&gt;(T expected)</code> An alias to <code>toBe</code>, kept for styling purposes. Both are interchangeable <code>operator==</code> <code>toBeTruthy()</code> Passes if <code>value</code> equals true, evaluated through expression <code>(value)</code> <code>operator==</code> <code>toBeFalsy()</code> Passes if <code>value</code> equals false, evaluated through expression <code>(!value)</code> <code>operator==</code>"},{"location":"reference/#floating-point-types","title":"Floating point types","text":"<p>These assertions apply to a <code>value</code> of any type <code>T</code> inheriting from <code>float</code> or <code>double</code>. All assertions which apply to any type <code>T</code> also apply to this type.</p> Method Description <code>toBe&lt;T&gt;(T expected, T epsilon)</code> Passes if the absolute distance between <code>value</code> and <code>expected</code> is less than the specified epsilon (\u03b5), evaluated through expression <code>fabs(actual - expected) &gt; epsilon</code>. Default epsilon (\u03b5) is \u03b5=10\u207b\u2074 for 32 bit float values, and \u03b5=10\u207b\u2076 for 64 bit float values <code>toEqual&lt;T&gt;(T expected, T epsilon)</code> An alias to <code>toBe</code>, kept for styling purposes. Both are interchangeable <code>toBeGreaterThan&lt;T&gt;(T expected)</code> Passes if <code>value</code> is greater than <code>expected</code> <code>toBeLessThan&lt;T&gt;(T expected)</code> Passes if <code>value</code> is smaller than <code>expected</code>"},{"location":"reference/#strings","title":"Strings","text":"<p>These assertions apply to a <code>value</code> of any type based on <code>std::string</code>. All assertions which apply to any type <code>T</code> also apply to this type.</p> Method Description <code>toBe&lt;T&gt;(T expected)</code> Passes if <code>value</code> matches <code>expected</code>, evaluated through expression <code>(value == expected)</code> <code>toEqual&lt;T&gt;(T expected)</code> An alias to <code>toBe</code>, kept for styling purposes. Both are interchangeable <code>toMatch(std::string expected)</code> Passes if string <code>value</code> contains substring <code>expected</code> <code>toMatch(Regex(x))</code> Passes if string <code>value</code> matches with regular expression defined in Regex macro. See example below. <code>toHaveLength(size_t length)</code> Passes if string <code>value</code> lexicographical length equals <code>length</code>"},{"location":"reference/#using-regular-expressions-for-string-matchers","title":"Using regular expressions for string matchers","text":"<p>Regular expression matchers accept any regular expression accepted by <code>std::regex</code>. The following examples are valid regular expression assertions:</p> <pre><code>it(\"asserts regexs matches\", []() {\n  expect(\"Hello world cest\").toMatch(Regex(\"^Hell.*cest$\"));\n  expect(\"I have 12 apples\").toMatch(Regex(\".*\\\\d+ apples\"));\n  expect(\"To match a partial match\").toMatch(Regex(\"\\\\w match$\"));\n});\n</code></pre>"},{"location":"reference/#collections","title":"Collections","text":"<p>Cest supports creating assertions for standard library collections. In the current version, <code>vector</code> is supported.</p>"},{"location":"reference/#stdvector","title":"<code>std::vector</code>","text":"<p>These assertions apply to a vector <code>value</code> of any type based on <code>std::vector&lt;T&gt;</code>. All assertions which apply to any type <code>T</code> also apply to this type.</p> <p>Warning</p> <p>To be able to perform assertions on objects of type <code>std::vector&lt;T&gt;</code>, template type <code>T</code> must support comparation through the operator <code>operator==</code>.</p> Method Description <code>toBe(std::vector&lt;T&gt; expected)</code> Passes if vector <code>value</code> contains the same number of items as <code>expected</code>, and all items contained in both vectors are equal and are at the same position <code>toEqual(std::vector&lt;T&gt; expected)</code> An alias to <code>toBe</code>, kept for styling purposes. Both are interchangeable <code>toContain(T item)</code> Passes if vector <code>value</code> contains an instance of <code>item</code> <code>toHaveLength(size_t length)</code> Passes if vector <code>value</code> number of items equals <code>length</code>"},{"location":"reference/#pointers","title":"Pointers","text":"<p>These assertions apply to a <code>value</code> of any pointer type <code>T*</code>.</p> Method Description <code>toEqualMemory(T *expected, size_t length)</code> Passes if <code>value</code> matches byte by byte compared wit <code>expected</code>, from address <code>expected</code> until <code>expected + length</code> <code>toBeNull()</code> Passes if <code>value</code> equals address <code>0x0</code> <code>toBeNotNull()</code> Passes if <code>value</code> does not equal address <code>0x0</code>"},{"location":"reference/#exceptions","title":"Exceptions","text":"<p>Cest supports asserting whether the result of an arbitrary expression raises a C++ exception based on type <code>std::exception</code>. The interface must be executed inside an <code>it</code> block, and accepts a lambda function (the asserted expression).</p> <p>See the following example:</p> <pre><code>void readFile(std::string path) {\n  if (path == \"\") {\n    throw std::exception(\"Bad path!\");\n  }\n}\n\ndescribe(\"File reader\", []() {\n  it(\"fails to read files with empty path\", []() {\n    std::string path = \"\";\n\n    assertThrows&lt;std::exception&gt;([=]() {\n      readFile(path);\n    });\n  });\n});\n</code></pre>"},{"location":"reference/#adding-custom-assertions","title":"Adding custom assertions","text":"<p>To add custom assertions, the following methods must be implemented as template specializations of the built-in <code>expectFunction</code> and <code>Assertion</code> classes. You can find a full example in the GitHub repository, or follow this structure to get quick-started:</p> <pre><code>#include &lt;cest&gt;\n\ntemplate&lt;&gt;\nclass Assertion&lt;MyType&gt; {\npublic:\n  Assertion(const char *file, int line, MyType value) {\n    actual = value;\n    assertion_file = std::string(file);\n    assertion_line = line;\n  }\n\n  toBeWhatever(MyType other) {\n    if (other.foo() != actual.bar()) {\n      throw AssertionError(assertion_file, assertion_line, \"The failure message\")\n    }\n  }\n\nprivate:\n  MyType actual;\n  std::string assertion_file;\n  int assertion_line;\n};\n\ntemplate&lt;&gt;\nAssertion&lt;MyType&gt; expectFunction(const char *file, int line, MyType actual) {\n  return Assertion&lt;MyType&gt;(file, line, actual);\n}\n\ndescribe(\"Custom assertions\", []() {\n  it(\"overrides for MyType\", []() {\n    MyType a, b;\n    expect(a).toBeWhatever(b);\n  });\n});\n</code></pre>"},{"location":"reference/#parametrized-tests","title":"Parametrized tests","text":"<p>Cest supports parametrizing test execution. Given a defined set of values, a parametrized test will run once for each of the values in the set. The value is passed to the test as a function argument.</p> <p>This pattern is useful when building tests where the same behaviour has to be validated against a defined set of data (for example, when working with enumerated values or ranged sets).</p> <p>See the following example to see how to define a parametrized test, which validates summing two integers and validating its result:</p> <pre><code>struct OperandsAndResult {\n  int first;\n  int second;\n  int result;\n}\n\ndescribe(\"Calculator\", []() {\n  it(\"can add numbers\", []() {\n    withParameter&lt;OperandsAndResult&gt;()\n      .withValue(OperandsAndResult(1, 1, 2))\n      .withValue(OperandsAndResult(2, 3, 5))\n      .thenDo([](OperandsAndResult x) {\n        int sum = x.first + x.second;\n        expect(sum).toEqual(x.result);\n      });\n  });\n});\n</code></pre>"},{"location":"reference/#cest-test-runner-cli-parameters","title":"Cest test runner CLI parameters","text":"<p>Cest tests are stand-alone executables which have to be compiled and run individually. Execution behavior can be modified through command line options.</p> Option Description <code>-r</code>/<code>--randomize</code> Randomize test execution inside a single suite. Randomization uses <code>std::default_random_engine</code> <code>-s [seed]</code>/<code>--seed [seed]</code> Inject seed for randomization (should be an unsigned integer value) <code>-o</code> / <code>--only-suite-result</code> Only output the result of the whole test suite as a single line <code>-t</code> / <code>--tree-suite-result</code> Output the result of the test suite in tree format, with indents for each nested suite"},{"location":"reference/#cest-runner-cli-parameters","title":"Cest Runner CLI parameters","text":"<p>Cest runner can be used to launch and operate Cest tests in a simple way. Execution behavior can be modified through command line options.</p> Option Description <code>[directory]</code> Target directory to look for tests to run. Defaults to <code>$CWD</code> <code>--watch</code> Run in watch mode. An interactive UI is available to filter which tests should run."},{"location":"reference/#signal-behavior","title":"Signal behavior","text":"<p>The Cest test runner captures the following POSIX signals upon startup: <code>SIGSEGV</code>, <code>SIGFPE</code>, <code>SIGBUS</code>, <code>SIGILL</code>, <code>SIGTERM</code>, <code>SIGXCPU</code> and <code>SIGXFSZ</code>. Test are marked as failed if any of them raises during its execution. The POSIX function <code>signal()</code> is used for this purpose. Take this into account when testing code that captures signals, as both could interfer.</p>"},{"location":"reference/#leak-sanitizer-integration","title":"Leak Sanitizer integration","text":"<p>The Cest test runner detects whether the test program is being compiled with LSAN enabled by testing against the <code>__SANITIZE_ADDRESS__</code> define, which will be defined in all translation units by the compiler if LSAN is enabled. If LSAN is not enabled or not supported, LSAN integration is disabled.</p>"},{"location":"how-to/bare_c/","title":"Testing C code","text":"<p>There are many C testing frameworks, such as the excellent Unity Framework. If you wish to be able to create more semantic, expressive test for your C code, you can leverage building your tests in C++ with Cest Framework.</p>"},{"location":"how-to/bare_c/#setup","title":"Setup","text":"<p>To avoid introducing additional complexity to this example, we will invoke the C and C++ compilers directly. We will assume <code>gcc</code> and <code>g++</code> are available in your system.</p> <p>If you are using macOS and have installed XCode Build Tools, you will probably have to use CLang by invoking <code>clang</code> and <code>clang++</code>.</p> <p>Finally, let's install the latest version of Cest Framework. You can get the latest version from GitHub, or directly run in the terminal:</p> Installing Cest Framework<pre><code>wget https://github.com/cegonse/cest/releases/download/v3/cest\n</code></pre>"},{"location":"how-to/bare_c/#the-c-code-under-test","title":"The C code under test","text":"<p>As in the first example, we will create a simple calculator app. Let's start by creating a C file to hold the business logic, along with its header to export the function.</p> calculator.c<pre><code>#include \"calculator.h\"\n\nint Sum(int a, int b) {\n  return a + b;\n}\n</code></pre> calculator.h<pre><code>#pragma once\n\nint Sum(int a, int b);\n</code></pre>"},{"location":"how-to/bare_c/#the-test-suite-source-file","title":"The test suite source file","text":"<p>Then, let's create a C++ file to hold the test for our business logic. Check the annotations () to know more about each section of the test file.</p> calculator.test.cpp<pre><code>#include &lt;cest&gt;\n\nextern \"C\" // (1)\n{\n  #include &lt;calculator.h&gt;\n}\n\ndescribe(\"Calculator\", []() {\n  it(\"performs addition\", []() {\n    expect(Sum(2, 2)).toEqual(4);\n  });\n});\n</code></pre> <ol> <li>We indicate the <code>calculator.h</code> header file should be included following the C naming convention. The compiler would expect mangled symbols otherwise, and compilation would fail.</li> </ol>"},{"location":"how-to/bare_c/#compiling-the-c-test-with-the-c-code","title":"Compiling the C++ test with the C code","text":"<p>Now that we have all the source files in place, we can compile both the C code with the business logic, and the C++ test as a stand-alone executable.</p> <p>To do this, we will compile both source files as object files with their respective compilers (C and C++ compilers). Then, invoke the C++ compiler to link all the object files into a single executable.</p> Compiling and linking sources<pre><code>gcc -c calculator.c -o calculator.o\ng++ -I. -c calculator.test.cpp -o calculator.test.o\ng++ calculator.test.o calculator.o -o test_calculator\n</code></pre> <p>After compiling the test executable, we can run it to run our test:</p> Running the test<pre><code>./test_calculator\n PASS  calculator.test.cpp:9 performs addition\n</code></pre>"},{"location":"how-to/bare_c/#next-reading","title":"Next reading","text":"<p>After finishing this example, we have seen how to combine Cest Framework with C code to create expressive tests for your C code.</p> <p>You can combine this example with the CMake example to create a powerful build system, capable of combining your C code with C++ tests while automating building of execution of your tests and applications.</p> <p>In the next article, we will see how can use Cest Framework to easily detect memory leaks in our code ahead of time.</p> <ul> <li> Integrating with CMake</li> <li>Detecting memory leaks </li> </ul>"},{"location":"how-to/cmake/","title":"Integrating with CMake","text":"<p>In the previous guide, we went through how to set-up the project files for a simple calculator app. We went through how to build and run both the application and the tests by hand, invoking the compiler manually.</p> <p>In this guide, we are going to see how to automate the build and run process with CMake and Make. After completing this guide, you will be able to build complex C++ applications with multiple source files and multiple test suites.</p>"},{"location":"how-to/cmake/#pre-requisites","title":"Pre-requisites","text":"<p>To complete this guide, you must have a working installation of CMake. CMake is a widely used, powerful build system. Check the guides in the official CMake website to learn more about how to install and configure CMake in your machine.</p>"},{"location":"how-to/cmake/#setup","title":"Setup","text":"<p>This guide starts from the last point of the first guide (Writing your first test). If you haven't gone through the first guide, its recommended you go through that content first.</p> <p>After completing the first guide, the directory structure should look like this:</p> Directory structure<pre><code>/calculator\n\u251c /src\n\u2502 \u251c main.cpp\n\u2502 \u251c calculator.cpp\n\u2502 \u2514 calculator.h\n\u251c /test\n\u2502 \u2514 calculator.test.cpp\n\u251c /lib\n\u2502 \u2514 cest\n\u2514 /build\n  \u251c calculator_test\n  \u2514 calculator\n</code></pre>"},{"location":"how-to/cmake/#creating-the-makefile","title":"Creating the Makefile","text":"<p>Let's start by creating a simple Makefile recipe to automate the build, test, run and clean processes. We will place the Makefile at the root directory of the project. After creating the file, the directory structure should look like this:</p> Directory structure<pre><code>/calculator\n\u251c /src\n\u2502 \u251c main.cpp\n\u2502 \u251c calculator.cpp\n\u2502 \u2514 calculator.h\n\u251c /test\n\u2502 \u2514 calculator.test.cpp\n\u251c /lib\n\u2502 \u2514 cest\n\u251c /build\n\u2502 \u251c calculator_test\n\u2502 \u2514 calculator\n\u2514 Makefile\n</code></pre> <p>With a simple <code>clean</code> rule, we can dispose of the compiled files from the previous guide.</p> Rule to clean build files<pre><code>clean:\n  @rm -rf build/*\n\n.PHONY: clean # (1)\n</code></pre> <ol> <li>The <code>clean</code> build target is set as a <code>PHONY</code> build target, because we want to indicate Make that this target should not follow the dependency resolution mechanisms of Make. Check the Make documentation to know more.</li> </ol> <p>Next, we will add a rule to build all the source files in the project. Since we will be using CMake to run the compilation process, the build rule will just invoke CMake and compile the resulting Makefile generated by CMake:</p> Rule to build the project<pre><code>build:\n  cd build\n  cmake .. # (1)\n  make # (2)\n\nclean:\n  @rm -rf build/*\n\n.PHONY: clean build\n</code></pre> <ol> <li>CMake is invoked in the project parent directory, where the CMakeLists.txt file will reside. We will go through its contents in next sections.</li> <li>After CMake has completed preparing the project, we will have a Makefile available in the build directory. Invoking this Makefile will build the project.</li> </ol> <p>Finally, we will add two extra rules to execute the application and the tests, respectively. This will simplify the build and run process a lot from now on, as we will be able to run all tests with a single command:</p> Rules to run the application and tests<pre><code>run: build # (1)\n  ./build/app\n\ntest: build\n  @find $(pwd)/build -name \"test_*\" -type f -executable -print0 | xargs -0 -I % sh -c % # (2)\n\nbuild:\n  cd build\n  cmake ..\n  make\n\nclean:\n  @rm -rf build/*\n\n.PHONY: clean build run test\n</code></pre> <ol> <li>Both the <code>run</code> and <code>test</code> targets depend on the <code>build</code> target, as the project must be compiled prior to running the application or the tests.</li> <li>To run all the tests, we look for all executable files in the <code>build</code> folder named <code>test_*</code>. Then, found files are executed.</li> </ol>"},{"location":"how-to/cmake/#cmake-rules-to-build-the-application","title":"CMake rules to build the application","text":"<p>To be able to use CMake to build our project, we must create a set of rules CMake will follow to create the required dependency graph and be able to build all executables in the project. This rules are defined in <code>CMakeLists.txt</code> files.</p> <p>CMake is a complex and powerful language, check CMake's official website to learn more about it and find available bibliography.</p> <p>In this guide, we will create a very simple <code>CMakeLists.txt</code> file that will let us get started. We will create the file in the root directory of the project. After creating it, the directory structure should look like this:</p> Directory structure<pre><code>/calculator\n\u251c /src\n\u2502 \u251c main.cpp\n\u2502 \u251c calculator.cpp\n\u2502 \u2514 calculator.h\n\u251c /test\n\u2502 \u2514 calculator.test.cpp\n\u251c /lib\n\u2502 \u2514 cest\n\u251c /build\n\u2502 \u251c calculator_test\n\u2502 \u2514 calculator\n\u251c CMakeLists.txt\n\u2514 Makefile\n</code></pre> <p>Let's start by building the minimum set of rules to compile the calculator application into an executable. The generated binaries will be split in two parts: on one hand, the business logic will be inside a static library (<code>libcalculator.a</code>).</p> <p>On the other hand, the entrypoint of the application (<code>main.cpp</code>) will be compiled independently to generate the application's executable, linking against the static library.</p> <p>This will allow us to create each test suite as an independent executable file, linking to the static library to be able to access all the business logic from the test suite.</p> Basic rules to generate the library and application<pre><code>cmake_minimum_required(VERSION 3.5)\nproject(Calculator)\n\nset(CALCULATOR_SOURCES src/calculator.cpp)\nadd_library(calculator ${CALCULATOR_SOURCES})\n\nadd_executable(app src/main.cpp)\ntarget_link_libraries(app calculator)\n</code></pre> <p>After creating the CMake rules, test the whole set by cleaning and building the project. To do so, simply run: <pre><code>make clean build\n</code></pre></p> <p>Afterwards, the directory structure should be like:</p> Directory structure<pre><code>/calculator\n\u251c /src\n\u2502 \u251c main.cpp\n\u2502 \u251c calculator.cpp\n\u2502 \u2514 calculator.h\n\u251c /test\n\u2502 \u2514 calculator.test.cpp\n\u251c /lib\n\u2502 \u2514 cest\n\u251c /build\n\u2502 \u251c ... Many files generated by CMake\n\u2502 \u251c libcalculator.a\n\u2502 \u2514 app\n\u251c Makefile\n\u2514 CMakeLists.txt\n</code></pre> <p>Both the static library containing the business logic (<code>libcalculator.a</code>) and the application (<code>app</code>) have been compiled.</p>"},{"location":"how-to/cmake/#cmake-rules-to-build-the-tests","title":"CMake rules to build the tests","text":"<p>Now that all the application's business logic is being compiled into a static library, creating new test suites is as simple as linking each test suite file with the static library. This will generate a new executable with the test suite.</p> <p>The CMake rules to include the test suite from the previous example (<code>calculator.test.cpp</code>) would be like the following:</p> Rules to build all the project's binaries<pre><code>cmake_minimum_required(VERSION 3.5)\nproject(Calculator)\n\nset(CALCULATOR_SOURCES src/calculator.cpp)\nadd_library(calculator ${CALCULATOR_SOURCES})\n\nadd_executable(app src/main.cpp)\ntarget_link_libraries(app calculator)\n\nadd_executable(test_calculator test/calculator.test.cpp)\ntarget_link_libraries(test_calculator calculator)\n</code></pre> <p>After running the compilation process, the <code>test_calculator</code> test suite runnable file will be compiled.</p>"},{"location":"how-to/cmake/#next-reading","title":"Next reading","text":"<p>After completing this guide, we have seen how to integrate Cest Framework with CMake and automate the compilation of test suites and the application.</p> <p>CMake is a complex topic, and there is enormous flexibility on what you can achieve with it.</p> <p>In the next section, we will see how to use Cest Framework to test C code, adding powerful semantics to C testing.</p> <ul> <li> Using Cest Runner</li> <li>Testing C Code </li> </ul>"},{"location":"how-to/leak-detection/","title":"Detecting memory leaks","text":"<p>Memory leaks are one of the most common pitfalls C and C++ developers face when developing complex applications. Thankfully, there are many tools that help with detecting and avoiding memory leaks during development.</p> <p>One such tool is Google's Leak Sanitizer, part of Address Sanitiizer, which comes built-in with new versions of the GNU C Compiler and Clang. Leak Sanitizer instruments calls to memory allocations and deallocations, and generates a report upon program termination if there are any potential leaks.</p> <p>Cest Framework includes support to call Leak Sanitizer's instrumentation from the test itself, causing tests to fail when a leak is detected.</p> <p>In this how to guide, we will see how to compile a Cest Framework test with Leak Sanitizer enabled.</p>"},{"location":"how-to/leak-detection/#setup","title":"Setup","text":"<p>To avoid introducing additional complexity to this example, we will invoke the C++ compiler directly. We will assume <code>g++</code> is available in your system.</p> <p>If you are using macOS and have installed XCode Build Tools, you will probably have to use CLang by invoking <code>clang++</code>.</p> <p>Finally, let's install the latest version of Cest Framework. You can get the latest version from GitHub, or directly run in the terminal:</p> Installing Cest Framework<pre><code>wget https://github.com/cegonse/cest/releases/download/v3/cest\n</code></pre>"},{"location":"how-to/leak-detection/#test-code-with-a-memory-leak","title":"Test code with a memory leak","text":"<p>To showcase how Leak Sanitizer and Cest Framework work together, we will create a simple test that allocates memory but does not free it.</p> leak.test.cpp<pre><code>#include &lt;cest&gt;\n\ndescribe(\"Test with leaks\", []() {\n  it(\"does not free its memory\", []() {\n    int *ptr = new int;\n    *ptr = 123;\n  });\n});\n</code></pre>"},{"location":"how-to/leak-detection/#compiling-with-leak-sanitizer-support","title":"Compiling with Leak Sanitizer support","text":"<p>Now that we have the test file in place, we can compile it with Leak Sanitizer enabled. We will do so by enabling full address sanitization, as Leak Sanitizer is a sub-module of Address Sanitizer. Cest Framework will automatically detect that Leak Sanitizer has been enabled at compile time.</p> Compiling and linking sources<pre><code>g++ -g -I. -fsanitize=address leak.test.cpp -o test_leaks\n</code></pre> <p>After compiling the test executable, we can run it to see the results:</p> Running the test<pre><code>./test_leaks\n FAIL  leak.test.cpp:4 does not free its memory\n Failed at line 4: Detected potential memory leaks during test execution.\n   1 |\n   2 | describe(\"Test with leaks\", []() {\n   3 |   it(\"does not free its memory\", []() {\n &gt; 4 |     int *ptr = new int;\n   5 |     *ptr = 123;\n   6 |   });\n   7 | });\nAddressSanitizer result:\n\n=================================================================\n==14523==ERROR: LeakSanitizer: detected memory leaks\n\nDirect leak of 4 byte(s) in 1 object(s) allocated from:\n    #0 0x7fb10bd82647 in operator new(unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:99\n    #1 0x55ae1c44574f in operator() /tmp/leak.test.cpp:3\n    #2 0x55ae1c4473a9 in __invoke_impl&lt;void, &lt;lambda()&gt;::&lt;lambda()&gt;&amp;&gt; /usr/include/c++/10/bits/invoke.h:60\n    #3 0x55ae1c446dfc in __invoke_r&lt;void, &lt;lambda()&gt;::&lt;lambda()&gt;&amp;&gt; /usr/include/c++/10/bits/invoke.h:153\n    #4 0x55ae1c446696 in _M_invoke /usr/include/c++/10/bits/std_function.h:291\n    #5 0x55ae1c44aa07 in std::function&lt;void ()&gt;::operator()() const /usr/include/c++/10/bits/std_function.h:622\n    #6 0x55ae1c442584 in cest::runTestSuite(cest::TestSuite*) cest:664\n    #7 0x55ae1c445390 in main cest:1366\n    #8 0x7fb10b93fd09 in __libc_start_main ../csu/libc-start.c:308\n\nSUMMARY: AddressSanitizer: 4 byte(s) leaked in 1 allocation(s).\n</code></pre> <p>Understanding Leak Sanitizer's stack traces takes some time to get used to, but we can see how in the frame #1 (corresponding to the leak.test.cpp file), there is a leak detected in line 3. This line matches with our test, which is not releasing the memory as it should.</p> <ul> <li> Testing C Code</li> </ul>"},{"location":"how-to/runner/","title":"Using Cest Runner","text":"<p>In the previous guide, we went through how to integrate Cest Framework with your application and run tests bare-bones. However, this isn't the easiest way to run Cest test suites.</p> <p>In this guide, we are going to see how to use the Cest Runner to simplify running test suites and working interactively with your test cases.</p>"},{"location":"how-to/runner/#setup","title":"Setup","text":"<p>This guide starts from the last point of the first guide (Writing your first test). If you haven't gone through the first guide, its recommended you go through that content first.</p> <p>After completing the first guide, the directory structure should look like this:</p> Directory structure<pre><code>/calculator\n\u251c /src\n\u2502 \u251c main.cpp\n\u2502 \u251c calculator.cpp\n\u2502 \u2514 calculator.h\n\u251c /test\n\u2502 \u2514 calculator.test.cpp\n\u251c /lib\n\u2502 \u2514 cest\n\u2514 /build\n  \u251c calculator_test\n  \u2514 calculator\n</code></pre> <p>First, we'll download the latest version of cest-runner from GitHub. Right now, only Linux x64 builds of the Cest Runner are provided in GitHub. If you are running other platform (such as macOS or FreeBSD) or CPU architecture, you will have to build Cest Runner yourself from sources.</p> <p>Let's create a <code>bin</code> directory to place the <code>cest-runner</code> binary:</p> <pre><code>mkdir -p bin\ncd bin &amp;&amp; wget https://github.com/cegonse/cest/releases/download/v3/cest-runner-x64-linux\nmv cest-runner-x64-linux cest-runner\nchmod +x cest-runner\ncd ..\n</code></pre> <p>After downloading the Cest Runner, the directory structure should look like this:</p> Directory structure<pre><code>/calculator\n\u251c /src\n\u2502 \u251c main.cpp\n\u2502 \u251c calculator.cpp\n\u2502 \u2514 calculator.h\n\u251c /test\n\u2502 \u2514 calculator.test.cpp\n\u251c /bin\n\u2502 \u2514 cest-runner\n\u251c /lib\n\u2502 \u2514 cest\n\u2514 /build\n  \u251c calculator_test\n  \u2514 calculator\n</code></pre>"},{"location":"how-to/runner/#running-the-test-suite","title":"Running the test suite","text":"<p>Now that Cest runner is installed, we can run all test suites by just executing <code>cest-runner</code>. Cest Runner finds all executable test files named <code>test_*</code> in the current working directory (or a directory passed as a command line argument), and executes all of them in sequence.</p> <pre><code>./bin/cest-runner\n  Calculator\n    sum()\n      \u2713 adds two numbers\n      \u2713 supports negative numbers\n\nTest Suites: 1 passed, 1 total\nTests:       2 passed, 2 total\nTime:        0.00165 s\nRan all test suites.\n</code></pre> <p>Let's force our test to fail. To do so, edit the implementation in <code>calculator.cpp</code> and change so the <code>sum()</code> function always returns zero.</p> <p>After compiling the test as we saw in the previous guide, and running <code>cest-runner</code>, we will see how the failure is detected:</p> <pre><code>./bin/cest-runner\n  Calculator\n    sum()\n      \u2715 adds two numbers\n\n   Failed at line 8: Expected 4, was 0\n   5 |     it(\"adds two numbers\", []() {\n   6 |       auto a = 2, b = 2;\n   7 |       auto r = Sum(a, b);\n &gt; 8 |       expect(r).toEqual(4); // (3)\n   9 |     });\n   10 |\n   11 |     it(\"supports negative numbers\", []() {\n\n      \u2715 supports negative numbers\n\n   Failed at line 14: Expected 2, was 0\n   11 |     it(\"supports negative numbers\", []() {\n   12 |       auto a = -2, b = 4;\n   13 |       auto r = Sum(a, b);\n &gt; 14 |       expect(r).toEqual(2);\n   15 |     });\n   16 |   });\n   17 | });\n\n\nTest Suites: 1 failed, 1 total\nTests:       2 failed, 2 total\nTime:        0.001543 s\nRan all test suites.\n</code></pre> <p>You can also run <code>cest-runner</code> in watch mode, to debug your tests interactively. You can filter by test suite source file name, or run only failed tests. You can do it as following:</p> <pre><code>./bin/cest-runner --watch\n  Calculator\n    sum()\n      \u2715 adds two numbers\n\n   Failed at line 8: Expected 4, was 0\n   5 |     it(\"adds two numbers\", []() {\n   6 |       auto a = 2, b = 2;\n   7 |       auto r = Sum(a, b);\n &gt; 8 |       expect(r).toEqual(4); // (3)\n   9 |     });\n   10 |\n   11 |     it(\"supports negative numbers\", []() {\n\n      \u2715 supports negative numbers\n\n   Failed at line 14: Expected 2, was 0\n   11 |     it(\"supports negative numbers\", []() {\n   12 |       auto a = -2, b = 4;\n   13 |       auto r = Sum(a, b);\n &gt; 14 |       expect(r).toEqual(2);\n   15 |     });\n   16 |   });\n   17 | });\n\nTest Suites: 1 failed, 1 total\nTests:       2 failed, 2 total\nTime:        0.001856 s\nRan all test suites.\n\nWatch Usage\n \u203a Press f to run only failed tests.\n \u203a Press p to filter by a filename regex pattern.\n \u203a Press q to quit watch mode.\n \u203a Press Enter to trigger a test run.\n</code></pre> <p>Follow the on-screen prompts to apply filters as you need. You will get the hang of it very quickly.</p>"},{"location":"how-to/runner/#next-reading","title":"Next reading","text":"<p>After completing this guide, we have seen how to use the Cest Runner to simplify execution of the test suites of your project. In this guide we only had a single test suite, which made it a bit pointless. But as the number of tests in your project grows, you will see the benefits of using Cest Runner quickly.</p> <p>In the next guide, we will see how to integrate Cest Framework with a complex build system such as CMake.</p> <ul> <li> Writing your first test</li> <li>Integrating with CMake </li> </ul>"},{"location":"quickstart/first/","title":"Writing your first test","text":"<p>In this example, we will create a simple calculator in C++ using Cest to test its behavior. To make things easy, we will run the build commands directly in the terminal, without using a build system. In the next tutorial, we will see how to integrate Cest with CMake.</p>"},{"location":"quickstart/first/#setup","title":"Setup","text":"<p>First, let's create an empty directory where we will keep all the project's files. Then, the subdirectories to keep the source and build results of the project.</p> Create all the directories<pre><code>mkdir calculator\ncd calculator\nmkdir src\nmkdir test\nmkdir lib\nmkdir build\n</code></pre> <p>The resulting directory structure will be like the following:</p> Directory structure<pre><code>/calculator\n\u251c /src\n\u251c /test\n\u251c /lib\n\u2514 /build\n</code></pre> <p>Now, let's create the application's source files. Let's start by creating a <code>main.cpp</code> file to hold the application's entrypoint, and a <code>calculator.cpp</code> file to hold the application's business logic.</p> <p>We will start by performing the sum of 2+2, but let's keep the implementation empty first. We will fill in the details after writing its test. That will ensure the calculation is correct.</p> src/main.cpp<pre><code>#include &lt;iostream&gt;\n#include \"calculator.h\"\n\nint main(int argc, char *argv[]) {\n  std::cout &lt;&lt; \"2+2 = \" &lt;&lt; Sum(2, 2) &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre> src/calculator.cpp<pre><code>int Sum(int a, int b) {\n  return 0;\n}\n</code></pre> src/calculator.h<pre><code>#pragma once\n\nint Sum(int a, int b);\n</code></pre> <p>After creating these files, the directory structure will look like this:</p> Directory structure<pre><code>/calculator\n\u251c /src\n\u2502 \u251c main.cpp\n\u2502 \u251c calculator.cpp\n\u2502 \u2514 calculator.h\n\u251c /test\n\u251c /lib\n\u2514 /build\n</code></pre> <p>Finally, let's install the latest version of Cest Framework. You can get the latest version from GitHub, or directly run in the terminal:</p> Installing Cest Framework<pre><code>cd lib\nwget https://github.com/cegonse/cest/releases/download/v3/cest\ncd ..\n</code></pre> <p>After these commands finish, we will have the full setup in place:</p> Directory structure<pre><code>/calculator\n\u251c /src\n\u2502 \u251c main.cpp\n\u2502 \u251c calculator.cpp\n\u2502 \u2514 calculator.h\n\u251c /test\n\u251c /lib\n\u2502 \u2514 cest\n\u2514 /build\n</code></pre>"},{"location":"quickstart/first/#building-the-application","title":"Building the application","text":"<p>To build the application, let's invoke the C++ compiler and build all the project's source files into a single binary. We will assume the GNU Compiler is installed, invoking <code>g++</code>. If you are using macOS and have installed the XCode Build Tools, you will probably have CLang installed instead. In that case, run <code>clang++</code>.</p> Building the application<pre><code>g++ src/main.cpp src/calculator.cpp -o build/calculator\n</code></pre> <p>If something went wrong during the compilation process, go to the previous step and check whether you are missing any file or you have any errors in the source files. Otherwise, the calculator program will be placed inside the <code>/build</code> directory:</p> Directory structure<pre><code>/calculator\n\u251c /src\n\u2502 \u251c main.cpp\n\u2502 \u251c calculator.cpp\n\u2502 \u2514 calculator.h\n\u251c /test\n\u251c /lib\n\u2502 \u2514 cest\n\u2514 /build\n  \u2514 calculator\n</code></pre> <p>Running the application will show the calculation result, which is wrong: Running the application<pre><code>./build/calculator\n2+2 = 0\n</code></pre></p>"},{"location":"quickstart/first/#writing-our-first-test","title":"Writing our first test","text":"<p>Now we have a calculator application that builds and runs, but the business logic is not implemented yet. Let's build its logic through a test, ensuring the behavior is correct.</p> <p>First, let's create the test file for the <code>calculator.cpp</code> file. Check the annotations () to know more about each section of the test file.</p> test/calculator.test.cpp<pre><code>#include &lt;cest&gt;\n#include &lt;calculator.h&gt;\n\ndescribe(\"Calculator\", []() { // (1)\n  describe(\"sum()\", []() { // (2)\n    it(\"adds two numbers\", []() {\n      auto a = 2, b = 2;\n      auto r = Sum(a, b);\n      expect(r).toEqual(4); // (3)\n    });\n\n    it(\"supports negative numbers\", []() {\n      auto a = -2, b = 4;\n      auto r = Sum(a, b);\n      expect(r).toEqual(2);\n    });\n  });\n});\n</code></pre> <ol> <li><code>describe</code> blocks define test-suites. Each test suite may have any number of tests.</li> <li>Test-suites can be nested one inside each other. Cest will run them in outside-in order.</li> <li><code>expect()</code> is the keyword that lets you do assertions on the calculation results of your code. The whole set of available assertions is available in the API reference</li> </ol> <p>With our test in place, let's build and run the calculator test. The test can be easily run by executing the compiled file, as Cest tests are stand-alone executable applications. Check out the different output styles in the API reference API reference or by running the test with the <code>--help</code> flag.</p> Compiling the test<pre><code>g++ -Ilib -Isrc src/calculator.cpp test/calculator.test.cpp -o build/calculator_test\n</code></pre> <p>After compiling the test, the directory structure will look like this:</p> Directory structure<pre><code>/calculator\n\u251c /src\n\u2502 \u251c main.cpp\n\u2502 \u251c calculator.cpp\n\u2502 \u2514 calculator.h\n\u251c /test\n\u2502 \u2514 calculator.test.cpp\n\u251c /lib\n\u2502 \u2514 cest\n\u2514 /build\n  \u251c calculator_test\n  \u2514 calculator\n</code></pre> <p>Finally, let's run the test and see its output. The output may look bare in this snippet, but you will see results with full color and rich text in the terminal.</p> Running the test<pre><code>./build/calculator_test\n FAIL  test/calculator.test.cpp:6 adds two numbers\n Failed at line 9: Expected 4, was 0\n FAIL  test/calculator.test.cpp:12 supports negative numbers\n Failed at line 15: Expected 2, was 0\n</code></pre> <p>We can see both tests have failed, as expected. Let's correct the implementation of our business logic to ensure the tests pass:</p> src/calculator.cpp<pre><code>int Sum(int a, int b) {\n  return a + b;\n}\n</code></pre> <p>And now, when running the tests:</p> Building and running the test again<pre><code>g++ -Ilib -Isrc src/calculator.cpp test/calculator.test.cpp -o build/calculator_test\n./build/calculator_test\n PASS  test/calculator.test.cpp:6 adds two numbers\n PASS  test/calculator.test.cpp:12 supports negative numbers\n</code></pre> <p>All tests have passed!  If we try compiling and running the application again, we will now see the correct result on the terminal:</p> Building and running the application<pre><code>g++ src/main.cpp src/calculator.cpp -o build/calculator\n./build/calculator\n2+2 = 4\n</code></pre>"},{"location":"quickstart/first/#next-reading","title":"Next reading","text":"<p>With this simple example, we have seen how does Cest Framework work, how to create a simple test, and how to integrate it with an application.</p> <p>Next, we will see how to integrate Cest Runner to easily manage our test suite.</p> <ul> <li>Using Cest Runner </li> </ul>"}]}