{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u2014 Cest is a C++ testing framework focused on simplicity and readability \u2014 A simple test Working with exceptions Advanced collection features Parametrized tests #include <cest> describe ( \"A mars rover\" , []() { it ( \"can go forward\" , []() { MarsRover rover ( 0 , 0 ); rover . move ( Direction :: Forward ); expect ( rover . position . x ). toBe ( 1 ); }); }); #include <cest> describe ( \"Discount vouchers\" , []() { it ( \"can only have positive discount\" , []() { assertRaises < InvalidDiscountException > () { DiscountVoucher voucher ( -30 ); } }); }); #include <cest> describe ( \"Message queue\" , []() { it ( \"can contain multiple messages\" , []() { std :: vector < string > pendingData { \"<header>\" , \"20 apples\" }; expect ( pendingData ). toHaveLength ( 2 ); expect ( pendingData ). toContain ( \"<header>); expect ( pendingData [ 1 ]). toMatch ( Regex ( \".* \\\\ d+ apples\" )); }); }); #include <cest> describe ( \"Hardware Version register\" , []() { it ( \"is mirrored in two addresses in the memory map\" , []() { withParameter < uint32_t *> (). withValue ( 0x00A1000F ). withValue ( 0xFFA1000F ). thenDo ([]( uint32_t * address ) { uint32_t version = * address ; expect ( version ). toBe ( 123 ); }); }); }); Main features Single Header All features are included in a single C++ header, making it easy to integrate into any project's existing pipeline. Just include cest in each test file to compile a self-contained and runnable test BDD inspired API Using from it to expect , write your tests as you would in JavaScript, Python or Ruby. One of the main objectives of Cest is slashing the learning curve towards C++ testing. No more esoteric syntax in C++ tests! Feature rich from the get-go Includes exception handling assertions, parametrized tests, pointer assertions, integration with STL collections, and more. Want more? Planned features include parametric tests, extended collection support, async support, and more Why yet another testing framework? asd","title":"Home"},{"location":"#cest-is-a-c-testing-framework-focused-on-simplicity-and-readability","text":"A simple test Working with exceptions Advanced collection features Parametrized tests #include <cest> describe ( \"A mars rover\" , []() { it ( \"can go forward\" , []() { MarsRover rover ( 0 , 0 ); rover . move ( Direction :: Forward ); expect ( rover . position . x ). toBe ( 1 ); }); }); #include <cest> describe ( \"Discount vouchers\" , []() { it ( \"can only have positive discount\" , []() { assertRaises < InvalidDiscountException > () { DiscountVoucher voucher ( -30 ); } }); }); #include <cest> describe ( \"Message queue\" , []() { it ( \"can contain multiple messages\" , []() { std :: vector < string > pendingData { \"<header>\" , \"20 apples\" }; expect ( pendingData ). toHaveLength ( 2 ); expect ( pendingData ). toContain ( \"<header>); expect ( pendingData [ 1 ]). toMatch ( Regex ( \".* \\\\ d+ apples\" )); }); }); #include <cest> describe ( \"Hardware Version register\" , []() { it ( \"is mirrored in two addresses in the memory map\" , []() { withParameter < uint32_t *> (). withValue ( 0x00A1000F ). withValue ( 0xFFA1000F ). thenDo ([]( uint32_t * address ) { uint32_t version = * address ; expect ( version ). toBe ( 123 ); }); }); });","title":"\u2014 Cest is a C++ testing framework focused on simplicity and readability \u2014"},{"location":"#main-features","text":"","title":"Main features"},{"location":"#single-header","text":"All features are included in a single C++ header, making it easy to integrate into any project's existing pipeline. Just include cest in each test file to compile a self-contained and runnable test","title":" Single Header"},{"location":"#bdd-inspired-api","text":"Using from it to expect , write your tests as you would in JavaScript, Python or Ruby. One of the main objectives of Cest is slashing the learning curve towards C++ testing. No more esoteric syntax in C++ tests!","title":" BDD inspired API"},{"location":"#feature-rich-from-the-get-go","text":"Includes exception handling assertions, parametrized tests, pointer assertions, integration with STL collections, and more. Want more? Planned features include parametric tests, extended collection support, async support, and more","title":" Feature rich from the get-go"},{"location":"#why-yet-another-testing-framework","text":"asd","title":"Why yet another testing framework?"},{"location":"quickstart/","text":"Quickstart Writing your first test Running the test Basic setup with CMake and C++ Setting-up Cest to work with C code Integrating into the CI pipeline","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"","title":"Quickstart"},{"location":"quickstart/#writing-your-first-test","text":"","title":"Writing your first test"},{"location":"quickstart/#running-the-test","text":"","title":"Running the test"},{"location":"quickstart/#basic-setup-with-cmake-and-c","text":"","title":"Basic setup with CMake and C++"},{"location":"quickstart/#setting-up-cest-to-work-with-c-code","text":"","title":"Setting-up Cest to work with C code"},{"location":"quickstart/#integrating-into-the-ci-pipeline","text":"","title":"Integrating into the CI pipeline"},{"location":"reference/","text":"API Reference Test definition Building blocks Test suites are defined by the describe block. Each describe block takes one lambda function as the main test body, and can have many it blocks. All the it blocks will be executed when running the test. Warning Due to how describe blocks are built in compilation-time, Cest does not support having multiple describe blocks in a single file, be it independently or nested. Execution can be controlled using the xit and fit keywords: xit will skip the test. fit will execute only that specific test. This can be useful if you want to avoid running a test that is not yet ready, or you want to focus in fixing a single test. Basic test definition describe ( \"each test suite\" , []() { it ( \"may contain\" , []() {}); it ( \"multiple test cases\" , []() {}); fit ( \"only this test will run\" , []() {}); xit ( \"this test will be skipped\" , []() {}); }); Pre-conditions and post-conditions Execution of test cases and suites can be wrapped to control setup and teardown using the beforeEach , afterEach , beforeAll and afterAll keywords. Order of execution of the setup and teardown keywords is beforeAll \u2192 beforeEach \u2192 test case \u2192 afterEach \u2192 afterAll . Warning Even though having multiple pre-condition or post-condition keywords in a single test suite will compile, the actual functions that will be used by Cest is not guaranteed in that case. To avoid problems, each test suite must contain only one of each. Using setup and teardown keywords is the best way to gracefully control post and pre-conditions in your test suites and cases. Wrapping each test case int * data = nullptr ; describe ( \"Behavior of pre and post conditions\" , []() { beforeEach ([]() { data = new int ; * data = 0 ; }); afterEach ([]() { delete data ; }); it ( \"has no memory leaks\" , []() { expect ( * data ). toEqual ( 0 ); }); }); Wrapping each test suite DatabaseConnection connection ; describe ( \"Behavior of pre and post conditions\" , []() { beforeAll ([]() { connection . connectTo ( \"localhost\" ); }); afterAll ([]() { connection . close (); }); it ( \"can perform queries\" , []() { expect ( connection . getById ( \"\" )). toBeNull (); }); }); Assertions Cest uses matchers to assert values in tests. Assertion keywords are generated through templates, ranging from common assertions to specialization to specific types (like strings, lists, etc...). An assertion failing to validate its value will stop the test, showing the error through the output. Remaining tests will continue to run. The basic form of any assertion is: expect < T > ( value ).[ assertion ](...); Where assertion can be comparing it to another value, validating its NULL, validating its empty... For example: expect ( \"hello\" ). toEqual ( \"bye\" ); // This will fail, as hello does not match bye expect ( 0x00000000 ). toBeNull (); // This will pass, as NULL equals zero Warning Since assertions are generated through templates, asserted type T must implement specific operators to match them to the target value. Basic (built-in) types implement them, but if using custom types (like classes or structures), the operators will have to be manually overloaded. Generic types These assertions apply to a value of any type T , including the ones Cest has a specialization for (see next sections). Method Description Equivalient operator toBe<T>(T expected) Passes if value matches expected , evaluated through expression (value == expected) operator== toEqual<T>(T expected) An alias to toBe , kept for styling purposes. Both are interchangeable operator== toBeTruthy() Passes if value equals true, evaluated through expression (value) operator== toBeFalsy() Passes if value equals false, evaluated through expression (!value) operator== Strings These assertions apply to a value of any type based on std::string . All assertions which apply to any type T also apply to this type. Method Description toMatch(std::string expected) Passes if string value contains substring expected toMatch(Regex(x)) Passes if string value matches with regular expression defined in Regex macro. See example below. toHaveLength(size_t length) Passes if string value lexicographical length equals length Using regular expressions for string matchers Regular expression matchers accept any regular expression accepted by std::regex . The following examples are valid regular expression assertions: it ( \"asserts regexs matches\" , []() { expect ( \"Hello world cest\" ). toMatch ( Regex ( \"^Hell.*cest$\" )); expect ( \"I have 12 apples\" ). toMatch ( Regex ( \".* \\\\ d+ apples\" )); expect ( \"To match a partial match\" ). toMatch ( Regex ( \" \\\\ w match$\" )); }); Collections Cest supports creating assertions for standard library collections. In the current version, vector is supported. std::vector These assertions apply to a vector value of any type based on std::vector<T> . All assertions which apply to any type T also apply to this type. Warning To be able to perform assertions on objects of type std::vector<T> , template type T must support comparation through the operator operator== . Method Description toEqual(std::vector<T> expected) Passes if vector value contains the same number of items as expected , and all items contained in both vectors are equal and are at the same position toContain(T item) Passes if vector value contains an instance of item toHaveLength(size_t length) Passes if vector value number of items equals length Pointers These assertions apply to a value of any pointer type T* . Method Description toEqualMemory(T *expected, size_t length) Passes if value matches byte by byte compared wit expected , from address expected until expected + length toBeNull() Passes if value equals address 0x0 toBeNotNull() Passes if value does not equal address 0x0 Exceptions Cest supports asserting whether the result of an arbitrary expression raises a C++ exception based on type std::exception . The interface must be executed inside an it block, and accepts a lambda function (the asserted expression). See the following example: void readFile ( std :: string path ) { if ( path == \"\" ) { throw std :: exception ( \"Bad path!\" ); } } describe ( \"File reader\" , []() { it ( \"fails to read files with empty path\" , []() { std :: string path = \"\" ; assertThrows < std :: exception > ([ = ]() { readFile ( path ); }); }); }); Parametrized tests Cest supports parametrizing test execution. Given a defined set of values, a parametrized test will run once for each of the values in the set. The value is passed to the test as a function argument. This pattern is useful when building tests where the same behaviour has to be validated against a defined set of data (for example, when working with enumerated values or ranged sets). See the following example to see how to define a parametrized test, which validates summing two integers and validating its result: struct OperandsAndResult { int first ; int second ; int result ; } describe ( \"Calculator\" , []() { it ( \"can add numbers\" , []() { withParameter < OperandsAndResult > () . withValue ( OperandsAndResult ( 1 , 1 , 2 )) . withValue ( OperandsAndResult ( 2 , 3 , 5 )) . thenDo ([]( OperandsAndResult x ) { int sum = x . first + x . second ; expect ( sum ). toEqual ( x . result ); }); }); }); Cest runner CLI parameters Signal behavior","title":"API Reference"},{"location":"reference/#api-reference","text":"","title":"API Reference"},{"location":"reference/#test-definition","text":"","title":"Test definition"},{"location":"reference/#building-blocks","text":"Test suites are defined by the describe block. Each describe block takes one lambda function as the main test body, and can have many it blocks. All the it blocks will be executed when running the test. Warning Due to how describe blocks are built in compilation-time, Cest does not support having multiple describe blocks in a single file, be it independently or nested. Execution can be controlled using the xit and fit keywords: xit will skip the test. fit will execute only that specific test. This can be useful if you want to avoid running a test that is not yet ready, or you want to focus in fixing a single test. Basic test definition describe ( \"each test suite\" , []() { it ( \"may contain\" , []() {}); it ( \"multiple test cases\" , []() {}); fit ( \"only this test will run\" , []() {}); xit ( \"this test will be skipped\" , []() {}); });","title":"Building blocks"},{"location":"reference/#pre-conditions-and-post-conditions","text":"Execution of test cases and suites can be wrapped to control setup and teardown using the beforeEach , afterEach , beforeAll and afterAll keywords. Order of execution of the setup and teardown keywords is beforeAll \u2192 beforeEach \u2192 test case \u2192 afterEach \u2192 afterAll . Warning Even though having multiple pre-condition or post-condition keywords in a single test suite will compile, the actual functions that will be used by Cest is not guaranteed in that case. To avoid problems, each test suite must contain only one of each. Using setup and teardown keywords is the best way to gracefully control post and pre-conditions in your test suites and cases. Wrapping each test case int * data = nullptr ; describe ( \"Behavior of pre and post conditions\" , []() { beforeEach ([]() { data = new int ; * data = 0 ; }); afterEach ([]() { delete data ; }); it ( \"has no memory leaks\" , []() { expect ( * data ). toEqual ( 0 ); }); }); Wrapping each test suite DatabaseConnection connection ; describe ( \"Behavior of pre and post conditions\" , []() { beforeAll ([]() { connection . connectTo ( \"localhost\" ); }); afterAll ([]() { connection . close (); }); it ( \"can perform queries\" , []() { expect ( connection . getById ( \"\" )). toBeNull (); }); });","title":"Pre-conditions and post-conditions"},{"location":"reference/#assertions","text":"Cest uses matchers to assert values in tests. Assertion keywords are generated through templates, ranging from common assertions to specialization to specific types (like strings, lists, etc...). An assertion failing to validate its value will stop the test, showing the error through the output. Remaining tests will continue to run. The basic form of any assertion is: expect < T > ( value ).[ assertion ](...); Where assertion can be comparing it to another value, validating its NULL, validating its empty... For example: expect ( \"hello\" ). toEqual ( \"bye\" ); // This will fail, as hello does not match bye expect ( 0x00000000 ). toBeNull (); // This will pass, as NULL equals zero Warning Since assertions are generated through templates, asserted type T must implement specific operators to match them to the target value. Basic (built-in) types implement them, but if using custom types (like classes or structures), the operators will have to be manually overloaded.","title":"Assertions"},{"location":"reference/#generic-types","text":"These assertions apply to a value of any type T , including the ones Cest has a specialization for (see next sections). Method Description Equivalient operator toBe<T>(T expected) Passes if value matches expected , evaluated through expression (value == expected) operator== toEqual<T>(T expected) An alias to toBe , kept for styling purposes. Both are interchangeable operator== toBeTruthy() Passes if value equals true, evaluated through expression (value) operator== toBeFalsy() Passes if value equals false, evaluated through expression (!value) operator==","title":"Generic types"},{"location":"reference/#strings","text":"These assertions apply to a value of any type based on std::string . All assertions which apply to any type T also apply to this type. Method Description toMatch(std::string expected) Passes if string value contains substring expected toMatch(Regex(x)) Passes if string value matches with regular expression defined in Regex macro. See example below. toHaveLength(size_t length) Passes if string value lexicographical length equals length","title":"Strings"},{"location":"reference/#using-regular-expressions-for-string-matchers","text":"Regular expression matchers accept any regular expression accepted by std::regex . The following examples are valid regular expression assertions: it ( \"asserts regexs matches\" , []() { expect ( \"Hello world cest\" ). toMatch ( Regex ( \"^Hell.*cest$\" )); expect ( \"I have 12 apples\" ). toMatch ( Regex ( \".* \\\\ d+ apples\" )); expect ( \"To match a partial match\" ). toMatch ( Regex ( \" \\\\ w match$\" )); });","title":"Using regular expressions for string matchers"},{"location":"reference/#collections","text":"Cest supports creating assertions for standard library collections. In the current version, vector is supported.","title":"Collections"},{"location":"reference/#stdvector","text":"These assertions apply to a vector value of any type based on std::vector<T> . All assertions which apply to any type T also apply to this type. Warning To be able to perform assertions on objects of type std::vector<T> , template type T must support comparation through the operator operator== . Method Description toEqual(std::vector<T> expected) Passes if vector value contains the same number of items as expected , and all items contained in both vectors are equal and are at the same position toContain(T item) Passes if vector value contains an instance of item toHaveLength(size_t length) Passes if vector value number of items equals length","title":"std::vector"},{"location":"reference/#pointers","text":"These assertions apply to a value of any pointer type T* . Method Description toEqualMemory(T *expected, size_t length) Passes if value matches byte by byte compared wit expected , from address expected until expected + length toBeNull() Passes if value equals address 0x0 toBeNotNull() Passes if value does not equal address 0x0","title":"Pointers"},{"location":"reference/#exceptions","text":"Cest supports asserting whether the result of an arbitrary expression raises a C++ exception based on type std::exception . The interface must be executed inside an it block, and accepts a lambda function (the asserted expression). See the following example: void readFile ( std :: string path ) { if ( path == \"\" ) { throw std :: exception ( \"Bad path!\" ); } } describe ( \"File reader\" , []() { it ( \"fails to read files with empty path\" , []() { std :: string path = \"\" ; assertThrows < std :: exception > ([ = ]() { readFile ( path ); }); }); });","title":"Exceptions"},{"location":"reference/#parametrized-tests","text":"Cest supports parametrizing test execution. Given a defined set of values, a parametrized test will run once for each of the values in the set. The value is passed to the test as a function argument. This pattern is useful when building tests where the same behaviour has to be validated against a defined set of data (for example, when working with enumerated values or ranged sets). See the following example to see how to define a parametrized test, which validates summing two integers and validating its result: struct OperandsAndResult { int first ; int second ; int result ; } describe ( \"Calculator\" , []() { it ( \"can add numbers\" , []() { withParameter < OperandsAndResult > () . withValue ( OperandsAndResult ( 1 , 1 , 2 )) . withValue ( OperandsAndResult ( 2 , 3 , 5 )) . thenDo ([]( OperandsAndResult x ) { int sum = x . first + x . second ; expect ( sum ). toEqual ( x . result ); }); }); });","title":"Parametrized tests"},{"location":"reference/#cest-runner-cli-parameters","text":"","title":"Cest runner CLI parameters"},{"location":"reference/#signal-behavior","text":"","title":"Signal behavior"}]}