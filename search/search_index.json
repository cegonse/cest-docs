{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\u2014 C++ testing made simple \u2014","text":"A simple testWorking with exceptionsAdvanced collection featuresParametrized tests <pre><code>#include &lt;cest&gt;\ndescribe(\"A mars rover\", []() {\nit(\"can go forward\", []() {\nMarsRover rover(0,0);\nrover.move(Direction::Forward);\nexpect(rover.position.x).toBe(1);\n});\n});\n</code></pre> <pre><code>#include &lt;cest&gt;\ndescribe(\"Discount vouchers\", []() {\nit(\"can only have positive discount\", []() {\nassertRaises&lt;InvalidDiscountException&gt;() {\nDiscountVoucher voucher(-30);\n}\n});\n});\n</code></pre> <pre><code>#include &lt;cest&gt;\ndescribe(\"Message queue\", []() {\nit(\"can contain multiple messages\", []() {\nstd::vector&lt;string&gt; pendingData { \"&lt;header&gt;\", \"20 apples\" };\nexpect(pendingData).toHaveLength(2);\nexpect(pendingData).toContain(\"&lt;header&gt;);\nexpect(pendingData[1]).toMatch(Regex(\".*\\\\d+ apples\"));\n});\n});\n</code></pre> <pre><code>#include &lt;cest&gt;\ndescribe(\"Hardware Version register\", []() {\nit(\"is mirrored in two addresses in the memory map\", []() {\nwithParameter&lt;uint32_t *&gt;().\nwithValue(0x00A1000F).\nwithValue(0xFFA1000F).\nthenDo([](uint32_t *address) {\nuint32_t version = *address;\nexpect(version).toBe(123);\n});\n});\n});\n</code></pre>"},{"location":"#main-features","title":"Main features","text":""},{"location":"#single-header","title":"Single Header","text":"<p>All features are included in a single C++ header, making it easy to integrate into any project's existing pipeline. Just include <code>cest</code> in each test file to compile a self-contained and runnable test</p>"},{"location":"#bdd-inspired-api","title":"BDD inspired API","text":"<p>Using from <code>it</code> to <code>expect</code>, write your tests as you would in JavaScript, Python or Ruby. One of the main objectives of Cest is slashing the learning curve towards C++ testing. No more esoteric syntax in C++ tests!</p>"},{"location":"#feature-rich-from-the-get-go","title":"Feature rich from the get-go","text":"<p>Includes exception handling assertions, parametrized tests, pointer assertions, integration with STL collections, and more. Want more? Planned features include parametric tests, extended collection support, async support, and more</p>"},{"location":"#why-yet-another-testing-framework","title":"Why yet another testing framework?","text":""},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#writing-your-first-test","title":"Writing your first test","text":""},{"location":"quickstart/#running-the-test","title":"Running the test","text":""},{"location":"quickstart/#basic-setup-with-cmake-and-c","title":"Basic setup with CMake and C++","text":""},{"location":"quickstart/#setting-up-cest-to-work-with-c-code","title":"Setting-up Cest to work with C code","text":""},{"location":"quickstart/#integrating-into-the-ci-pipeline","title":"Integrating into the CI pipeline","text":""},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#test-definition","title":"Test definition","text":""},{"location":"reference/#building-blocks","title":"Building blocks","text":"<p>Test suites are defined by the <code>describe</code> block. Each <code>describe</code> block takes one lambda function as the main test body, and can have many <code>it</code> blocks. All the <code>it</code> blocks will be executed when running the test.</p> <p>Warning</p> <p>Due to how <code>describe</code> blocks are built in compilation-time, Cest does not support having multiple <code>describe</code> blocks in a single file, be it independently or nested.</p> <p>Execution can be controlled using the <code>xit</code> and <code>fit</code> keywords:</p> <ul> <li><code>xit</code> will skip the test.</li> <li><code>fit</code> will execute only that specific test.</li> </ul> <p>This can be useful if you want to avoid running a test that is not yet ready, or you want to focus in fixing a single test.</p> <p>Basic test definition</p> <pre><code>describe(\"each test suite\", []() {\nit(\"may contain\", []() {});\nit(\"multiple test cases\", []() {});\nfit(\"only this test will run\", []() {});\nxit(\"this test will be skipped\", []() {});\n});\n</code></pre>"},{"location":"reference/#pre-conditions-and-post-conditions","title":"Pre-conditions and post-conditions","text":"<p>Execution of test cases and suites can be wrapped to control setup and teardown using the <code>beforeEach</code>, <code>afterEach</code>, <code>beforeAll</code> and <code>afterAll</code> keywords. Order of execution of the setup and teardown keywords is <code>beforeAll</code> \u2192 <code>beforeEach</code> \u2192 test case \u2192 <code>afterEach</code> \u2192 <code>afterAll</code>.</p> <p>Warning</p> <p>Even though having multiple pre-condition or post-condition keywords in a single test suite will compile, the actual functions that will be used by Cest is not guaranteed in that case. To avoid problems, each test suite must contain only one of each.</p> <p>Using setup and teardown keywords is the best way to gracefully control post and pre-conditions in your test suites and cases.</p> <p>Wrapping each test case</p> <pre><code>int *data = nullptr;\ndescribe(\"Behavior of pre and post conditions\", []() {\nbeforeEach([]() {\ndata = new int;\n*data = 0;\n});\nafterEach([]() {\ndelete data;\n});\nit(\"has no memory leaks\", []() {\nexpect(*data).toEqual(0);\n});\n});\n</code></pre> <p>Wrapping each test suite</p> <pre><code>DatabaseConnection connection;\ndescribe(\"Behavior of pre and post conditions\", []() {\nbeforeAll([]() {\nconnection.connectTo(\"localhost\");\n});\nafterAll([]() {\nconnection.close();\n});\nit(\"can perform queries\", []() {\nexpect(connection.getById(\"\")).toBeNull();\n});\n});\n</code></pre>"},{"location":"reference/#assertions","title":"Assertions","text":"<p>Cest uses matchers to assert values in tests. Assertion keywords are generated through templates, ranging from common assertions to specialization to specific types (like strings, lists, etc...).</p> <p>An assertion failing to validate its value will stop the test, showing the error through the output. Remaining tests will continue to run.</p> <p>The basic form of any assertion is:</p> <pre><code>expect&lt;T&gt;(value).[assertion](...);\n</code></pre> <p>Where assertion can be comparing it to another value, validating its NULL, validating its empty... For example:</p> <pre><code>expect(\"hello\").toEqual(\"bye\"); // This will fail, as hello does not match bye\nexpect(0x00000000).toBeNull(); // This will pass, as NULL equals zero\n</code></pre> <p>Warning</p> <p>Since assertions are generated through templates, asserted type <code>T</code> must implement specific operators to match them to the target value. Basic (built-in) types implement them, but if using custom types (like classes or structures), the operators will have to be manually overloaded.</p>"},{"location":"reference/#generic-types","title":"Generic types","text":"<p>These assertions apply to a <code>value</code> of any type <code>T</code>, including the ones Cest has a specialization for (see next sections).</p> Method Description Equivalient operator <code>toBe&lt;T&gt;(T expected)</code> Passes if <code>value</code> matches <code>expected</code>, evaluated through expression <code>(value == expected)</code> <code>operator==</code> <code>toEqual&lt;T&gt;(T expected)</code> An alias to <code>toBe</code>, kept for styling purposes. Both are interchangeable <code>operator==</code> <code>toBeTruthy()</code> Passes if <code>value</code> equals true, evaluated through expression <code>(value)</code> <code>operator==</code> <code>toBeFalsy()</code> Passes if <code>value</code> equals false, evaluated through expression <code>(!value)</code> <code>operator==</code>"},{"location":"reference/#floating-point-types","title":"Floating point types","text":"<p>These assertions apply to a <code>value</code> of any type <code>T</code> inheriting from <code>float</code> or <code>double</code>. All assertions which apply to any type <code>T</code> also apply to this type.</p> Method Description <code>toBe&lt;T&gt;(T expected, T epsilon)</code> Passes if the absolute distance between <code>value</code> and <code>expected</code> is less than the specified epsilon (\u03b5), evaluated through expression <code>fabs(actual - expected) &gt; epsilon</code>. Default epsilon (\u03b5) is \u03b5=10\u207b\u2074 for 32 bit float values, and \u03b5=10\u207b\u2076 for 64 bit float values <code>toEqual&lt;T&gt;(T expected, T epsilon)</code> An alias to <code>toBe</code>, kept for styling purposes. Both are interchangeable"},{"location":"reference/#strings","title":"Strings","text":"<p>These assertions apply to a <code>value</code> of any type based on <code>std::string</code>. All assertions which apply to any type <code>T</code> also apply to this type.</p> Method Description <code>toMatch(std::string expected)</code> Passes if string <code>value</code> contains substring <code>expected</code> <code>toMatch(Regex(x))</code> Passes if string <code>value</code> matches with regular expression defined in Regex macro. See example below. <code>toHaveLength(size_t length)</code> Passes if string <code>value</code> lexicographical length equals <code>length</code>"},{"location":"reference/#using-regular-expressions-for-string-matchers","title":"Using regular expressions for string matchers","text":"<p>Regular expression matchers accept any regular expression accepted by <code>std::regex</code>. The following examples are valid regular expression assertions:</p> <pre><code>it(\"asserts regexs matches\", []() {\nexpect(\"Hello world cest\").toMatch(Regex(\"^Hell.*cest$\"));\nexpect(\"I have 12 apples\").toMatch(Regex(\".*\\\\d+ apples\"));\nexpect(\"To match a partial match\").toMatch(Regex(\"\\\\w match$\"));\n});\n</code></pre>"},{"location":"reference/#collections","title":"Collections","text":"<p>Cest supports creating assertions for standard library collections. In the current version, <code>vector</code> is supported.</p>"},{"location":"reference/#stdvector","title":"<code>std::vector</code>","text":"<p>These assertions apply to a vector <code>value</code> of any type based on <code>std::vector&lt;T&gt;</code>. All assertions which apply to any type <code>T</code> also apply to this type.</p> <p>Warning</p> <p>To be able to perform assertions on objects of type <code>std::vector&lt;T&gt;</code>, template type <code>T</code> must support comparation through the operator <code>operator==</code>.</p> Method Description <code>toEqual(std::vector&lt;T&gt; expected)</code> Passes if vector <code>value</code> contains the same number of items as <code>expected</code>, and all items contained in both vectors are equal and are at the same position <code>toContain(T item)</code> Passes if vector <code>value</code> contains an instance of <code>item</code> <code>toHaveLength(size_t length)</code> Passes if vector <code>value</code> number of items equals <code>length</code>"},{"location":"reference/#pointers","title":"Pointers","text":"<p>These assertions apply to a <code>value</code> of any pointer type <code>T*</code>.</p> Method Description <code>toEqualMemory(T *expected, size_t length)</code> Passes if <code>value</code> matches byte by byte compared wit <code>expected</code>, from address <code>expected</code> until <code>expected + length</code> <code>toBeNull()</code> Passes if <code>value</code> equals address <code>0x0</code> <code>toBeNotNull()</code> Passes if <code>value</code> does not equal address <code>0x0</code>"},{"location":"reference/#exceptions","title":"Exceptions","text":"<p>Cest supports asserting whether the result of an arbitrary expression raises a C++ exception based on type <code>std::exception</code>. The interface must be executed inside an <code>it</code> block, and accepts a lambda function (the asserted expression).</p> <p>See the following example:</p> <pre><code>void readFile(std::string path) {\nif (path == \"\") {\nthrow std::exception(\"Bad path!\");\n}\n}\ndescribe(\"File reader\", []() {\nit(\"fails to read files with empty path\", []() {\nstd::string path = \"\";\nassertThrows&lt;std::exception&gt;([=]() {\nreadFile(path);\n});\n});\n});\n</code></pre>"},{"location":"reference/#parametrized-tests","title":"Parametrized tests","text":"<p>Cest supports parametrizing test execution. Given a defined set of values, a parametrized test will run once for each of the values in the set. The value is passed to the test as a function argument.</p> <p>This pattern is useful when building tests where the same behaviour has to be validated against a defined set of data (for example, when working with enumerated values or ranged sets).</p> <p>See the following example to see how to define a parametrized test, which validates summing two integers and validating its result:</p> <pre><code>struct OperandsAndResult {\nint first;\nint second;\nint result;\n}\ndescribe(\"Calculator\", []() {\nit(\"can add numbers\", []() {\nwithParameter&lt;OperandsAndResult&gt;()\n.withValue(OperandsAndResult(1, 1, 2))\n.withValue(OperandsAndResult(2, 3, 5))\n.thenDo([](OperandsAndResult x) {\nint sum = x.first + x.second;\nexpect(sum).toEqual(x.result);\n});\n});\n});\n</code></pre>"},{"location":"reference/#cest-runner-cli-parameters","title":"Cest runner CLI parameters","text":"<p>Cest tests are stand-alone executables which have to be compiled and run individually. Execution behavior can be modified through command line options.</p> Option Description <code>-q</code>/<code>--quiet</code> Supress normal output (use only <code>.</code> for passed tests and a red <code>F</code> for failed tests) <code>-r</code>/<code>--randomize</code> Randomize test execution inside a single suite. Randomization uses <code>std::default_random_engine</code> <code>-s [seed]</code>/<code>--seed [seed]</code> Inject seed for randomization (should be an unsigned integer value)"},{"location":"reference/#signal-behavior","title":"Signal behavior","text":"<p>The Cest runner captures the following POSIX signals upon startup: <code>SIGSEGV</code>, <code>SIGFPE</code>, <code>SIGBUS</code>, <code>SIGILL</code>, <code>SIGTERM</code>, <code>SIGXCPU</code> and <code>SIGXFSZ</code>. Test are marked as failed if any of them raises during its execution. The POSIX function <code>signal()</code> is used for this purpose. Take this into account when testing code that captures signals, as both could interfer.</p>"}]}