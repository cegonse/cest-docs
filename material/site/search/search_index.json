{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u2014 Cest is a C++ testing framework focused on simplicity and readability \u2014 A simple test Working with exceptions Advanced collection features Parametrized tests #include <cest> describe ( \"A mars rover\" , []() { it ( \"can go forward\" , []() { MarsRover rover ( 0 , 0 ); rover . move ( Direction :: Forward ); expect ( rover . position . x ). toBe ( 1 ); }); }); #include <cest> describe ( \"Discount vouchers\" , []() { it ( \"can only have positive discount\" , []() { assertRaises < InvalidDiscountException > () { DiscountVoucher voucher ( -30 ); } }); }); #include <cest> describe ( \"Message queue\" , []() { it ( \"can contain multiple messages\" , []() { std :: vector < string > pendingData { \"<header>\" , \"20 apples\" }; expect ( pendingData ). toHaveLength ( 2 ); expect ( pendingData ). toContain ( \"<header>); expect ( pendingData [ 1 ]). toMatch ( Regex ( \".* \\\\ d+ apples\" )); }); }); #include <cest> describe ( \"Hardware Version register\" , []() { it ( \"is mirrored in two addresses in the memory map\" , []() { withParameter < uint32_t *> (). withValue ( 0x00A1000F ). withValue ( 0xFFA1000F ). thenDo ([]( uint32_t * address ) { uint32_t version = * address ; expect ( version ). toBe ( 123 ); }); }); }); Main features Single Header All features are included in a single C++ header, making it easy to integrate into any project's existing pipeline. Just include cest in each test file to compile a self-contained and runnable test BDD inspired API Using from it to expect , write your tests as you would in JavaScript, Python or Ruby. One of the main objectives of Cest is slashing the learning curve towards C++ testing. No more esoteric syntax in C++ tests! Feature rich from the get-go Includes exception handling assertions, parametrized tests, pointer assertions, integration with STL collections, and more. Want more? Planned features include parametric tests, extended collection support, async support, and more Why yet another testing framework? asd","title":"Home"},{"location":"#cest-is-a-c-testing-framework-focused-on-simplicity-and-readability","text":"A simple test Working with exceptions Advanced collection features Parametrized tests #include <cest> describe ( \"A mars rover\" , []() { it ( \"can go forward\" , []() { MarsRover rover ( 0 , 0 ); rover . move ( Direction :: Forward ); expect ( rover . position . x ). toBe ( 1 ); }); }); #include <cest> describe ( \"Discount vouchers\" , []() { it ( \"can only have positive discount\" , []() { assertRaises < InvalidDiscountException > () { DiscountVoucher voucher ( -30 ); } }); }); #include <cest> describe ( \"Message queue\" , []() { it ( \"can contain multiple messages\" , []() { std :: vector < string > pendingData { \"<header>\" , \"20 apples\" }; expect ( pendingData ). toHaveLength ( 2 ); expect ( pendingData ). toContain ( \"<header>); expect ( pendingData [ 1 ]). toMatch ( Regex ( \".* \\\\ d+ apples\" )); }); }); #include <cest> describe ( \"Hardware Version register\" , []() { it ( \"is mirrored in two addresses in the memory map\" , []() { withParameter < uint32_t *> (). withValue ( 0x00A1000F ). withValue ( 0xFFA1000F ). thenDo ([]( uint32_t * address ) { uint32_t version = * address ; expect ( version ). toBe ( 123 ); }); }); });","title":"\u2014 Cest is a C++ testing framework focused on simplicity and readability \u2014"},{"location":"#main-features","text":"","title":"Main features"},{"location":"#single-header","text":"All features are included in a single C++ header, making it easy to integrate into any project's existing pipeline. Just include cest in each test file to compile a self-contained and runnable test","title":" Single Header"},{"location":"#bdd-inspired-api","text":"Using from it to expect , write your tests as you would in JavaScript, Python or Ruby. One of the main objectives of Cest is slashing the learning curve towards C++ testing. No more esoteric syntax in C++ tests!","title":" BDD inspired API"},{"location":"#feature-rich-from-the-get-go","text":"Includes exception handling assertions, parametrized tests, pointer assertions, integration with STL collections, and more. Want more? Planned features include parametric tests, extended collection support, async support, and more","title":" Feature rich from the get-go"},{"location":"#why-yet-another-testing-framework","text":"asd","title":"Why yet another testing framework?"},{"location":"quickstart/","text":"Quickstart Writing your first test Running the test Basic setup with CMake and C++ Setting-up Cest to work with C code Integrating into the CI pipeline","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"","title":"Quickstart"},{"location":"quickstart/#writing-your-first-test","text":"","title":"Writing your first test"},{"location":"quickstart/#running-the-test","text":"","title":"Running the test"},{"location":"quickstart/#basic-setup-with-cmake-and-c","text":"","title":"Basic setup with CMake and C++"},{"location":"quickstart/#setting-up-cest-to-work-with-c-code","text":"","title":"Setting-up Cest to work with C code"},{"location":"quickstart/#integrating-into-the-ci-pipeline","text":"","title":"Integrating into the CI pipeline"},{"location":"reference/","text":"API Reference Test definition Building blocks Test suites are defined by the describe block. Each describe block takes one lambda function as the main test body, and can have many it blocks. All the it blocks will be executed when running the test. Warning Due to how describe blocks are built in compilation-time, Cest does not support having multiple describe blocks in a single file, be it independently or nested. Execution can be controlled using the xit and fit keywords. xit will skip the test, while fit will execute only that specific test. This can be useful if you want to avoid running a test that is not yet ready, or you want to focus in fixing a single test. Basic test definition describe ( \"each test suite\" , []() { it ( \"may contain\" , []() {}); it ( \"multiple test cases\" , []() {}); fit ( \"only this test will run\" , []() {}); xit ( \"this test will be skipped\" , []() {}); }); Pre-conditions and post-conditions Execution of test cases and suites can be wrapped to control setup and teardown using the beforeEach , afterEach , beforeAll and afterAll keywords. Order of execution of the setup and teardown keywords is beforeAll \u2192 beforeEach \u2192 test case \u2192 afterEach \u2192 afterAll . Warning Even though having multiple pre-condition or post-condition keywords in a single test suite will compile, the actual functions that will be used by Cest is not guaranteed in that case. To avoid problems, each test suite must contain only one of each. Using setup and teardown keywords is the best way to gracefully control post and pre-conditions in your test suites and cases. Wrapping each test case int * data = nullptr ; describe ( \"Behavior of pre and post conditions\" , []() { beforeEach ([]() { data = new int ; * data = 0 ; }); afterEach ([]() { delete data ; }); it ( \"has no memory leaks\" , []() { expect ( * data ). toEqual ( 0 ); }); }); Wrapping each test suite DatabaseConnection connection ; describe ( \"Behavior of pre and post conditions\" , []() { beforeAll ([]() { connection . connectTo ( \"localhost\" ); }); afterAll ([]() { connection . close (); }); it ( \"can perform queries\" , []() { expect ( connection . getById ( \"\" )). toBeNull (); }); }); Assertions Cest uses matchers to assert values in tests. Assertion keywords are generated through templates, ranging from common assertions to specialization to specific types (like strings, lists, etc...). An assertion failing to validate its value will stop the test, showing the error through the output. Remaining tests will continue to run. The basic form of any assertion is: expect < T > ( value ).[ assertion ](...); Where assertion can be comparing it to another value, validating its NULL, validating its empty... For example: expect ( \"hello\" ). toEqual ( \"bye\" ); // This will fail, as hello does not match bye expect ( 0x00000000 ). toBeNull (); // This will pass, as NULL equals zero Warning Since assertions are generated through templates, asserted type T must implement specific operators to match them to the target value. Basic (built-in) types implement them, but if using custom types (like classes or structures), the operators will have to be manually overloaded. Generic types These assertions apply to any type T which is not included in the following sections. Method Description Comparation operator toBe<T>(T expected) Passes if value matches expected , evaluated through expression (value == expected) operator== toEqual<T>(T expected) An alias to toBe , kept for styling purposes. Both are interchangeable operator== toBeTruthy() Passes if value equals true, evaluated through expression (value) operator== toBeFalsy() Passes if value equals false, evaluated through expression (!value) operator== Strings Collections Pointers Exceptions Parametrized tests Extending the assertions Cest runner CLI parameters Signal behavior","title":"API Reference"},{"location":"reference/#api-reference","text":"","title":"API Reference"},{"location":"reference/#test-definition","text":"","title":"Test definition"},{"location":"reference/#building-blocks","text":"Test suites are defined by the describe block. Each describe block takes one lambda function as the main test body, and can have many it blocks. All the it blocks will be executed when running the test. Warning Due to how describe blocks are built in compilation-time, Cest does not support having multiple describe blocks in a single file, be it independently or nested. Execution can be controlled using the xit and fit keywords. xit will skip the test, while fit will execute only that specific test. This can be useful if you want to avoid running a test that is not yet ready, or you want to focus in fixing a single test. Basic test definition describe ( \"each test suite\" , []() { it ( \"may contain\" , []() {}); it ( \"multiple test cases\" , []() {}); fit ( \"only this test will run\" , []() {}); xit ( \"this test will be skipped\" , []() {}); });","title":"Building blocks"},{"location":"reference/#pre-conditions-and-post-conditions","text":"Execution of test cases and suites can be wrapped to control setup and teardown using the beforeEach , afterEach , beforeAll and afterAll keywords. Order of execution of the setup and teardown keywords is beforeAll \u2192 beforeEach \u2192 test case \u2192 afterEach \u2192 afterAll . Warning Even though having multiple pre-condition or post-condition keywords in a single test suite will compile, the actual functions that will be used by Cest is not guaranteed in that case. To avoid problems, each test suite must contain only one of each. Using setup and teardown keywords is the best way to gracefully control post and pre-conditions in your test suites and cases. Wrapping each test case int * data = nullptr ; describe ( \"Behavior of pre and post conditions\" , []() { beforeEach ([]() { data = new int ; * data = 0 ; }); afterEach ([]() { delete data ; }); it ( \"has no memory leaks\" , []() { expect ( * data ). toEqual ( 0 ); }); }); Wrapping each test suite DatabaseConnection connection ; describe ( \"Behavior of pre and post conditions\" , []() { beforeAll ([]() { connection . connectTo ( \"localhost\" ); }); afterAll ([]() { connection . close (); }); it ( \"can perform queries\" , []() { expect ( connection . getById ( \"\" )). toBeNull (); }); });","title":"Pre-conditions and post-conditions"},{"location":"reference/#assertions","text":"Cest uses matchers to assert values in tests. Assertion keywords are generated through templates, ranging from common assertions to specialization to specific types (like strings, lists, etc...). An assertion failing to validate its value will stop the test, showing the error through the output. Remaining tests will continue to run. The basic form of any assertion is: expect < T > ( value ).[ assertion ](...); Where assertion can be comparing it to another value, validating its NULL, validating its empty... For example: expect ( \"hello\" ). toEqual ( \"bye\" ); // This will fail, as hello does not match bye expect ( 0x00000000 ). toBeNull (); // This will pass, as NULL equals zero Warning Since assertions are generated through templates, asserted type T must implement specific operators to match them to the target value. Basic (built-in) types implement them, but if using custom types (like classes or structures), the operators will have to be manually overloaded.","title":"Assertions"},{"location":"reference/#generic-types","text":"These assertions apply to any type T which is not included in the following sections. Method Description Comparation operator toBe<T>(T expected) Passes if value matches expected , evaluated through expression (value == expected) operator== toEqual<T>(T expected) An alias to toBe , kept for styling purposes. Both are interchangeable operator== toBeTruthy() Passes if value equals true, evaluated through expression (value) operator== toBeFalsy() Passes if value equals false, evaluated through expression (!value) operator==","title":"Generic types"},{"location":"reference/#strings","text":"","title":"Strings"},{"location":"reference/#collections","text":"","title":"Collections"},{"location":"reference/#pointers","text":"","title":"Pointers"},{"location":"reference/#exceptions","text":"","title":"Exceptions"},{"location":"reference/#parametrized-tests","text":"","title":"Parametrized tests"},{"location":"reference/#extending-the-assertions","text":"","title":"Extending the assertions"},{"location":"reference/#cest-runner-cli-parameters","text":"","title":"Cest runner CLI parameters"},{"location":"reference/#signal-behavior","text":"","title":"Signal behavior"}]}